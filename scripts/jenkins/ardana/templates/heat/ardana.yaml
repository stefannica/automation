heat_template_version: 2016-10-14

description: >
  Template for deploying cloud {{ input_model.cloud.name }}.

parameters:
  key_name:
    type: string
    label: Key Name
    description: Name of key-pair to be used for compute instance
    default: engcloud-cloud-ci

resources:

  # networks and subnets
{% set virt_config = input_model.virtual %}
{% set ns = namespace(mgmt_network_name='', extapi_network_name='', extvm_network_name='', in_use=False, cp={}) %}

{% set mgmt_cidr = '%s/%s'.format(input_model.baremetal.subnet, input_model.baremetal.netmask) | ipaddr('net') %}

{% for network in input_model.networks %}



{%   if ns.in_use %}

{%     set network_name = network.name|lower|replace('-','_')|regex_replace('-net$', '') %}
{%     set ns.default_cidr = virt_config['dummy-cidr'] %}

# Get default CIDR for external neutron networks
{%     for network_group in input_model['network-groups'] if network['network-group'] == network_group.name and
         'neutron.l3_agent.external_network_bridge' in network_group.tags|default([]) %}
{%       for config_data in ns.cp['configuration-data'] if 'neutron' in input_model['configuration-data'][config_data] %}
{%         for ext_net in input_model['configuration-data'][config_data].data.neutron_external_networks|default([]) %}
{%           set ns.default_cidr = ext_net.cidr %}
{%           set ns.default_gateway = ext_net.gateway %}
{%         endfor %}
{%       endfor %}
{%     endfor %}

{%     set cidr = network.cidr|default(ns.default_cidr) %}

# the "management" network is the network that (is in use and) has the same CIDR as that used in the baremetal settings
{%     if network.cidr|default('') == mgmt_cidr %}
{%       set ns.mgmt_network_name = network_name %}
{%     endif %}

# networks that require special handling:
#  - neutron external networks:
#    - identification: tagged with neutron.l3_agent.external_network_bridge
#    - the CIDR and gateway configured for Ardana neutron must be the same as that configured for the OS subnet
#    - the OS subnet must be connected to the external router
#    - all this is needed to make the network behave like an external network
#  - neutron provider networks:
#    - identification: tagged with neutron.networks.<vlan/vxlan/...>
#    - a CIDR and gateway are usually configured for the input model network if needed by underlay (vxlan/gre)
#    Q: what happens when this is shared (e.g. with the "management" network) ?
#  - the "management" network:
#    - the CIDR must be the same as configured in the baremetal settings
#    - DHCP must be enabled and the IP addresses allocated to VMs must correspond to those configured in the server settings
#    - the OS subnet must be connected to the external router
#    - floating IP is associated with "management" IP of the CLM node
#    NOTE: can be different than the CONF network and the MANAGEMENT network, especially if it must be shielded from external access
#  - the Ardana VMs need access to the "external API" network via the neutron external networks and vice-versa
#    - the "external API" network must be added to the external router
#  - networks-groups with routes configured. The route can point to either:
#    - default: this network needs external access (needs to be added to the external router)
#    - one of the other global networks: both global networks need to be added to the same router
#    (not the external router, if at least one of them doesn't need external access)
#    NOTE: this means that there's another route configured for the other network, or that its
#    default route leads to this network
#    - one of the neutron networks: both this network and the one used to implement the
#    neutron network need to be added to the same router (not the external router, if at least one of them
#    doesn't need external access)
#    NOTE: this means that there's another route configured for the other network, or that its
#    default route leads to this network

# CIDRs for networks that don't have one specified:
#  - the external network (tagged with neutron.l3_agent.external_network_bridge): taken from the neutron configuration

  network_{{ network_name }}:
    type: OS::Neutron::Net
    properties:
      port_security_enabled: False

  subnet_{{ network_name }}:
    type: OS::Neutron::Subnet
    properties:
      network_id: { get_resource: network_{{ network_name }} }
      cidr: "{{ cidr }}"
      allocation_pools:
        - start: "{{ cidr | ipaddr('net') | ipaddr(2) }}"
          end: "{{ cidr | ipaddr('net') | ipaddr(-2) }}"
      ip_version: 4
{%     if network['gateway-ip'] is defined %}
      gateway_ip: "{{ network['gateway-ip'] }}"
{%     endif %}
{%     if network.cidr|default('') != mgmt_cidr %}
      enable_dhcp: False
{%     endif %}

{%   endif %}
{% endfor %}
  # router
  router_ext:
    type: OS::Neutron::Router
    properties:
      external_gateway_info:
        network: floating

  router_mgmt_interface:
    type: OS::Neutron::RouterInterface
    properties:
      router_id: { get_resource: router_mgmt }
      subnet_id: { get_resource: subnet_{{ ns.mgmt_network_name }} }

  #router_external_api_interface:
  #  type: OS::Neutron::RouterInterface
  #  properties:
  #    router_id: { get_resource: router_mgmt }
  #    subnet_id: { get_resource: subnet_external_api }

  #router_external_vm_interface:
  #  type: OS::Neutron::RouterInterface
  #  properties:
  #    router_id: { get_resource: router_mgmt }
  #    subnet_id: { get_resource: subnet_external_vm }

  # floating IPs
  mgmt-floatingip:
    type: OS::Neutron::FloatingIP
    properties:
      floating_network: floating



  # instances

{% for server in input_model.servers %}

# determine if server is in use

{%   set ns.in_use = False %}
{%   for cp in input_model['control-planes'] %}
{%     for service_group in (cp['clusters']|default([]) + cp['resources']|default([])) %}
{%       for server in input_model.servers if server.role == service_group['server-role'] %}
{%         set ns.in_use = True %}
{%       endfor %}
{%     endfor %}
{%   endfor %}

{%   if ns.in_use %}


{%     set server_name = server.id|lower|replace('-','_') %}
{%     set image_id = virt_config.images[server.id]|default(virt_config.images[server['role']])|default(virt_config.images['default']) %}
{%     set image_id = image_id[server['distro-id']]|default(image_id) %}
{%     set flavor_id = virt_config.flavors[server.id]|default(virt_config.flavors[server['role']])|default(virt_config.flavors['default']) %}

{%     set ns = namespace(disk_model={}, interface_model={}, disks=[], port_names=[]) %}
{%     for server_role in input_model['server-roles'] if server_role.name == server.role %}
{%       for disk_model in input_model['disk-models'] if disk_model.name == server_role['disk-model'] %}
{%         set ns.disk_model = disk_model  %}
{%       endfor %}
{%       for interface_model in input_model['interface-models'] if interface_model.name == server_role['interface-model'] %}
{%         set ns.interface_model = interface_model  %}
{%       endfor %}
{%     endfor %}


{%     for interface in ns.interface_model['network-interfaces'] %}
{%       for network_group in (interface['network-groups']|default([]) + interface['forced-network-groups']|default([])) %}
{%         for network in input_model.networks if network_group == network['network-group'] %}
{%           set network_name = network.name|lower|replace('-','_')|regex_replace('-net$', '') %}
{%           for device in (interface['bond-data']|default({})).devices|default([interface.device.name]) %}

{%             set port_name = "%s_%s_%s"|format(server_name, network_name, device) %}
{%             set _ = ns.port_names.append(port_name) %}
  {{ port_name }}:
    type: OS::Neutron::Port
    properties:
      network: { get_resource: network_{{ network_name }} }
      fixed_ips:
        - subnet_id: { get_resource: subnet_{{ network_name }} }
{%             if network.cidr|default('') == mgmt_cidr and loop.index0 == 0 %}
        - ip_address: {{ server['ip-addr'] }}
{%             endif %}

{%           endfor %}
{%         endfor %}
{%       endfor %}
{%     endfor %}

{%     for volume_group in (ns.disk_model['volume-groups']|default([]) or []) %}
{%       set ns.disks = ns.disks+volume_group['physical-volumes']|default([]) %}
{%     endfor %}

{%     for device_group in (ns.disk_model['device-groups']|default([]) or []) %}
{%       set ns.disks = ns.disks+device_group.devices|default([]) %}
{%     endfor %}

{%     for disk in ns.disks|unique if disk != '/dev/sda_root' %}
{%       set volume_name = "%s_%s"|format(server_name, disk|replace('/dev/', '')) %}
  {{ volume_name }}:
    type: OS::Cinder::Volume
    properties:
      size: 30

  {{ server_name }}_vol_att_{{ disk|replace('/dev/', '') }}:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: {{ server_name }} }
      volume_id: { get_resource: {{ volume_name }} }
      mountpoint: {{ disk }}

{%     endfor %}

  {{ server_name }}:
    type: OS::Nova::Server
    properties:
      key_name: { get_param: key_name }
      image: {{ image_id }}
      flavor: {{ flavor_id }}
      networks:
{%     for port_name in ns.port_names %}
        - port: { get_resource: {{ port_name }} }
{%     endfor %}
{%   endif %}
{% endfor %}

  deployer-floating-assignment:
    type: OS::Neutron::FloatingIPAssociation
    properties:
      floatingip_id: { get_resource: deployer-floatingip }
      port_id: { get_resource: deployer_mgmt_port }

outputs:
  # deployer
  deployer-ip-floating:
    description: Floating IP address of the deployer node
    value: { get_attr: [deployer-floatingip, floating_ip_address] }

  deployer-net-mgmt-ip:
    description: IP address of the deployer in the mgmt network
    value: { get_attr: [deployer, networks, { get_resource: network_mgmt }, 0]}

  # controller
  controllers-net-mgmt-ips:
    description: List of IPs of the controllers in the mgmt network
    value: { list_join: ["\n", { get_attr: [controllers, networks, { get_resource: network_mgmt }, 0]} ]}

  # computes
  computes-net-mgmt-ips:
    description: List of IPs of the computes on the mgmt network
    value: { list_join: ["\n", { get_attr: [computes, networks, { get_resource: network_mgmt }, 0]} ]}

  # network info
  network-mgmt-id:
    description: Neutron Network ID of management network
    value: { get_resource: network_mgmt }
